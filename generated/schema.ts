// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class ProjectToken extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProjectToken entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ProjectToken must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ProjectToken", id.toString(), this);
    }
  }

  static load(id: string): ProjectToken | null {
    return changetype<ProjectToken | null>(store.get("ProjectToken", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get name(): string {
    let value = this.get("name");
    return value!.toString();
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get symbol(): string {
    let value = this.get("symbol");
    return value!.toString();
  }

  set symbol(value: string) {
    this.set("symbol", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }
}

export class ContractAddPrjToken extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ContractAddPrjToken entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ContractAddPrjToken must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ContractAddPrjToken", id.toString(), this);
    }
  }

  static load(id: string): ContractAddPrjToken | null {
    return changetype<ContractAddPrjToken | null>(
      store.get("ContractAddPrjToken", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get tokenPrj(): Bytes {
    let value = this.get("tokenPrj");
    return value!.toBytes();
  }

  set tokenPrj(value: Bytes) {
    this.set("tokenPrj", Value.fromBytes(value));
  }
}

export class ContractBorrow extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ContractBorrow entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ContractBorrow must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ContractBorrow", id.toString(), this);
    }
  }

  static load(id: string): ContractBorrow | null {
    return changetype<ContractBorrow | null>(store.get("ContractBorrow", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get who(): Bytes {
    let value = this.get("who");
    return value!.toBytes();
  }

  set who(value: Bytes) {
    this.set("who", Value.fromBytes(value));
  }

  get borrowToken(): Bytes {
    let value = this.get("borrowToken");
    return value!.toBytes();
  }

  set borrowToken(value: Bytes) {
    this.set("borrowToken", Value.fromBytes(value));
  }

  get borrowAmount(): BigInt {
    let value = this.get("borrowAmount");
    return value!.toBigInt();
  }

  set borrowAmount(value: BigInt) {
    this.set("borrowAmount", Value.fromBigInt(value));
  }

  get prjAddress(): Bytes {
    let value = this.get("prjAddress");
    return value!.toBytes();
  }

  set prjAddress(value: Bytes) {
    this.set("prjAddress", Value.fromBytes(value));
  }

  get prjAmount(): BigInt {
    let value = this.get("prjAmount");
    return value!.toBigInt();
  }

  set prjAmount(value: BigInt) {
    this.set("prjAmount", Value.fromBigInt(value));
  }
}

export class ContractDeposit extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ContractDeposit entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ContractDeposit must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ContractDeposit", id.toString(), this);
    }
  }

  static load(id: string): ContractDeposit | null {
    return changetype<ContractDeposit | null>(store.get("ContractDeposit", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get who(): Bytes {
    let value = this.get("who");
    return value!.toBytes();
  }

  set who(value: Bytes) {
    this.set("who", Value.fromBytes(value));
  }

  get tokenPrj(): Bytes {
    let value = this.get("tokenPrj");
    return value!.toBytes();
  }

  set tokenPrj(value: Bytes) {
    this.set("tokenPrj", Value.fromBytes(value));
  }

  get lendingToken(): Bytes {
    let value = this.get("lendingToken");
    return value!.toBytes();
  }

  set lendingToken(value: Bytes) {
    this.set("lendingToken", Value.fromBytes(value));
  }

  get prjDepositAmount(): BigInt {
    let value = this.get("prjDepositAmount");
    return value!.toBigInt();
  }

  set prjDepositAmount(value: BigInt) {
    this.set("prjDepositAmount", Value.fromBigInt(value));
  }

  get beneficiary(): Bytes {
    let value = this.get("beneficiary");
    return value!.toBytes();
  }

  set beneficiary(value: Bytes) {
    this.set("beneficiary", Value.fromBytes(value));
  }
}

export class ContractLiquidate extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ContractLiquidate entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ContractLiquidate must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ContractLiquidate", id.toString(), this);
    }
  }

  static load(id: string): ContractLiquidate | null {
    return changetype<ContractLiquidate | null>(
      store.get("ContractLiquidate", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get liquidator(): Bytes {
    let value = this.get("liquidator");
    return value!.toBytes();
  }

  set liquidator(value: Bytes) {
    this.set("liquidator", Value.fromBytes(value));
  }

  get borrower(): Bytes {
    let value = this.get("borrower");
    return value!.toBytes();
  }

  set borrower(value: Bytes) {
    this.set("borrower", Value.fromBytes(value));
  }

  get lendingToken(): Bytes {
    let value = this.get("lendingToken");
    return value!.toBytes();
  }

  set lendingToken(value: Bytes) {
    this.set("lendingToken", Value.fromBytes(value));
  }

  get prjAddress(): Bytes {
    let value = this.get("prjAddress");
    return value!.toBytes();
  }

  set prjAddress(value: Bytes) {
    this.set("prjAddress", Value.fromBytes(value));
  }

  get amountPrjLiquidated(): BigInt {
    let value = this.get("amountPrjLiquidated");
    return value!.toBigInt();
  }

  set amountPrjLiquidated(value: BigInt) {
    this.set("amountPrjLiquidated", Value.fromBigInt(value));
  }
}

export class ContractLiquidationIncentiveSet extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save ContractLiquidationIncentiveSet entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ContractLiquidationIncentiveSet must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ContractLiquidationIncentiveSet", id.toString(), this);
    }
  }

  static load(id: string): ContractLiquidationIncentiveSet | null {
    return changetype<ContractLiquidationIncentiveSet | null>(
      store.get("ContractLiquidationIncentiveSet", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get tokenPrj(): Bytes {
    let value = this.get("tokenPrj");
    return value!.toBytes();
  }

  set tokenPrj(value: Bytes) {
    this.set("tokenPrj", Value.fromBytes(value));
  }

  get ltfNumerator(): i32 {
    let value = this.get("ltfNumerator");
    return value!.toI32();
  }

  set ltfNumerator(value: i32) {
    this.set("ltfNumerator", Value.fromI32(value));
  }

  get ltfDenominator(): i32 {
    let value = this.get("ltfDenominator");
    return value!.toI32();
  }

  set ltfDenominator(value: i32) {
    this.set("ltfDenominator", Value.fromI32(value));
  }
}

export class ContractLiquidationThresholdFactorSet extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save ContractLiquidationThresholdFactorSet entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ContractLiquidationThresholdFactorSet must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ContractLiquidationThresholdFactorSet", id.toString(), this);
    }
  }

  static load(id: string): ContractLiquidationThresholdFactorSet | null {
    return changetype<ContractLiquidationThresholdFactorSet | null>(
      store.get("ContractLiquidationThresholdFactorSet", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get tokenPrj(): Bytes {
    let value = this.get("tokenPrj");
    return value!.toBytes();
  }

  set tokenPrj(value: Bytes) {
    this.set("tokenPrj", Value.fromBytes(value));
  }

  get ltfNumerator(): i32 {
    let value = this.get("ltfNumerator");
    return value!.toI32();
  }

  set ltfNumerator(value: i32) {
    this.set("ltfNumerator", Value.fromI32(value));
  }

  get ltfDenominator(): i32 {
    let value = this.get("ltfDenominator");
    return value!.toI32();
  }

  set ltfDenominator(value: i32) {
    this.set("ltfDenominator", Value.fromI32(value));
  }
}

export class ContractLoanToValueRatioSet extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save ContractLoanToValueRatioSet entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ContractLoanToValueRatioSet must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ContractLoanToValueRatioSet", id.toString(), this);
    }
  }

  static load(id: string): ContractLoanToValueRatioSet | null {
    return changetype<ContractLoanToValueRatioSet | null>(
      store.get("ContractLoanToValueRatioSet", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get tokenPrj(): Bytes {
    let value = this.get("tokenPrj");
    return value!.toBytes();
  }

  set tokenPrj(value: Bytes) {
    this.set("tokenPrj", Value.fromBytes(value));
  }

  get lvrNumerator(): i32 {
    let value = this.get("lvrNumerator");
    return value!.toI32();
  }

  set lvrNumerator(value: i32) {
    this.set("lvrNumerator", Value.fromI32(value));
  }

  get lvrDenominator(): i32 {
    let value = this.get("lvrDenominator");
    return value!.toI32();
  }

  set lvrDenominator(value: i32) {
    this.set("lvrDenominator", Value.fromI32(value));
  }
}

export class ContractRedeem extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ContractRedeem entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ContractRedeem must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ContractRedeem", id.toString(), this);
    }
  }

  static load(id: string): ContractRedeem | null {
    return changetype<ContractRedeem | null>(store.get("ContractRedeem", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get who(): Bytes {
    let value = this.get("who");
    return value!.toBytes();
  }

  set who(value: Bytes) {
    this.set("who", Value.fromBytes(value));
  }

  get redeemToken(): Bytes {
    let value = this.get("redeemToken");
    return value!.toBytes();
  }

  set redeemToken(value: Bytes) {
    this.set("redeemToken", Value.fromBytes(value));
  }

  get redeemBToken(): Bytes {
    let value = this.get("redeemBToken");
    return value!.toBytes();
  }

  set redeemBToken(value: Bytes) {
    this.set("redeemBToken", Value.fromBytes(value));
  }

  get redeemAmount(): BigInt {
    let value = this.get("redeemAmount");
    return value!.toBigInt();
  }

  set redeemAmount(value: BigInt) {
    this.set("redeemAmount", Value.fromBigInt(value));
  }
}

export class ContractRedeemUnderlying extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save ContractRedeemUnderlying entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ContractRedeemUnderlying must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ContractRedeemUnderlying", id.toString(), this);
    }
  }

  static load(id: string): ContractRedeemUnderlying | null {
    return changetype<ContractRedeemUnderlying | null>(
      store.get("ContractRedeemUnderlying", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get who(): Bytes {
    let value = this.get("who");
    return value!.toBytes();
  }

  set who(value: Bytes) {
    this.set("who", Value.fromBytes(value));
  }

  get redeemToken(): Bytes {
    let value = this.get("redeemToken");
    return value!.toBytes();
  }

  set redeemToken(value: Bytes) {
    this.set("redeemToken", Value.fromBytes(value));
  }

  get redeemBToken(): Bytes {
    let value = this.get("redeemBToken");
    return value!.toBytes();
  }

  set redeemBToken(value: Bytes) {
    this.set("redeemBToken", Value.fromBytes(value));
  }

  get redeemAmountUnderlying(): BigInt {
    let value = this.get("redeemAmountUnderlying");
    return value!.toBigInt();
  }

  set redeemAmountUnderlying(value: BigInt) {
    this.set("redeemAmountUnderlying", Value.fromBigInt(value));
  }
}

export class ContractRepayBorrow extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ContractRepayBorrow entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ContractRepayBorrow must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ContractRepayBorrow", id.toString(), this);
    }
  }

  static load(id: string): ContractRepayBorrow | null {
    return changetype<ContractRepayBorrow | null>(
      store.get("ContractRepayBorrow", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get who(): Bytes {
    let value = this.get("who");
    return value!.toBytes();
  }

  set who(value: Bytes) {
    this.set("who", Value.fromBytes(value));
  }

  get borrowToken(): Bytes {
    let value = this.get("borrowToken");
    return value!.toBytes();
  }

  set borrowToken(value: Bytes) {
    this.set("borrowToken", Value.fromBytes(value));
  }

  get borrowAmount(): BigInt {
    let value = this.get("borrowAmount");
    return value!.toBigInt();
  }

  set borrowAmount(value: BigInt) {
    this.set("borrowAmount", Value.fromBigInt(value));
  }

  get prjAddress(): Bytes {
    let value = this.get("prjAddress");
    return value!.toBytes();
  }

  set prjAddress(value: Bytes) {
    this.set("prjAddress", Value.fromBytes(value));
  }

  get isPositionFullyRepaid(): boolean {
    let value = this.get("isPositionFullyRepaid");
    return value!.toBoolean();
  }

  set isPositionFullyRepaid(value: boolean) {
    this.set("isPositionFullyRepaid", Value.fromBoolean(value));
  }
}

export class ContractRoleAdminChanged extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save ContractRoleAdminChanged entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ContractRoleAdminChanged must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ContractRoleAdminChanged", id.toString(), this);
    }
  }

  static load(id: string): ContractRoleAdminChanged | null {
    return changetype<ContractRoleAdminChanged | null>(
      store.get("ContractRoleAdminChanged", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get role(): Bytes {
    let value = this.get("role");
    return value!.toBytes();
  }

  set role(value: Bytes) {
    this.set("role", Value.fromBytes(value));
  }

  get previousAdminRole(): Bytes {
    let value = this.get("previousAdminRole");
    return value!.toBytes();
  }

  set previousAdminRole(value: Bytes) {
    this.set("previousAdminRole", Value.fromBytes(value));
  }

  get newAdminRole(): Bytes {
    let value = this.get("newAdminRole");
    return value!.toBytes();
  }

  set newAdminRole(value: Bytes) {
    this.set("newAdminRole", Value.fromBytes(value));
  }
}

export class ContractRoleGranted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ContractRoleGranted entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ContractRoleGranted must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ContractRoleGranted", id.toString(), this);
    }
  }

  static load(id: string): ContractRoleGranted | null {
    return changetype<ContractRoleGranted | null>(
      store.get("ContractRoleGranted", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get role(): Bytes {
    let value = this.get("role");
    return value!.toBytes();
  }

  set role(value: Bytes) {
    this.set("role", Value.fromBytes(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }
}

export class ContractRoleRevoked extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ContractRoleRevoked entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ContractRoleRevoked must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ContractRoleRevoked", id.toString(), this);
    }
  }

  static load(id: string): ContractRoleRevoked | null {
    return changetype<ContractRoleRevoked | null>(
      store.get("ContractRoleRevoked", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get role(): Bytes {
    let value = this.get("role");
    return value!.toBytes();
  }

  set role(value: Bytes) {
    this.set("role", Value.fromBytes(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }
}

export class ContractSupply extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ContractSupply entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ContractSupply must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ContractSupply", id.toString(), this);
    }
  }

  static load(id: string): ContractSupply | null {
    return changetype<ContractSupply | null>(store.get("ContractSupply", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get who(): Bytes {
    let value = this.get("who");
    return value!.toBytes();
  }

  set who(value: Bytes) {
    this.set("who", Value.fromBytes(value));
  }

  get supplyToken(): Bytes {
    let value = this.get("supplyToken");
    return value!.toBytes();
  }

  set supplyToken(value: Bytes) {
    this.set("supplyToken", Value.fromBytes(value));
  }

  get supplyAmount(): BigInt {
    let value = this.get("supplyAmount");
    return value!.toBigInt();
  }

  set supplyAmount(value: BigInt) {
    this.set("supplyAmount", Value.fromBigInt(value));
  }

  get supplyBToken(): Bytes {
    let value = this.get("supplyBToken");
    return value!.toBytes();
  }

  set supplyBToken(value: Bytes) {
    this.set("supplyBToken", Value.fromBytes(value));
  }

  get amountSupplyBTokenReceived(): BigInt {
    let value = this.get("amountSupplyBTokenReceived");
    return value!.toBigInt();
  }

  set amountSupplyBTokenReceived(value: BigInt) {
    this.set("amountSupplyBTokenReceived", Value.fromBigInt(value));
  }
}

export class ContractWithdraw extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ContractWithdraw entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ContractWithdraw must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ContractWithdraw", id.toString(), this);
    }
  }

  static load(id: string): ContractWithdraw | null {
    return changetype<ContractWithdraw | null>(
      store.get("ContractWithdraw", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get who(): Bytes {
    let value = this.get("who");
    return value!.toBytes();
  }

  set who(value: Bytes) {
    this.set("who", Value.fromBytes(value));
  }

  get tokenPrj(): Bytes {
    let value = this.get("tokenPrj");
    return value!.toBytes();
  }

  set tokenPrj(value: Bytes) {
    this.set("tokenPrj", Value.fromBytes(value));
  }

  get lendingToken(): Bytes {
    let value = this.get("lendingToken");
    return value!.toBytes();
  }

  set lendingToken(value: Bytes) {
    this.set("lendingToken", Value.fromBytes(value));
  }

  get prjWithdrawAmount(): BigInt {
    let value = this.get("prjWithdrawAmount");
    return value!.toBigInt();
  }

  set prjWithdrawAmount(value: BigInt) {
    this.set("prjWithdrawAmount", Value.fromBigInt(value));
  }

  get beneficiary(): Bytes {
    let value = this.get("beneficiary");
    return value!.toBytes();
  }

  set beneficiary(value: Bytes) {
    this.set("beneficiary", Value.fromBytes(value));
  }
}
