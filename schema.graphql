type ERC20Token @entity {
  id: ID!
  name: String!
  symbol: String!
  address: Bytes!
  linksNumber: BigDecimal
}

type ProjectToken @entity {
  id: ID!
  name: String!
  symbol: String!
  address: Bytes!
  updatedAt: BigInt!
  isDepositPaused: Boolean
  isWithdrawPaused: Boolean
  depositedAmount: BigDecimal
  lvr: BigDecimal
  pitAmount: BigDecimal
  depositingLevelAmount: BigDecimal
  currentDepositingLevel: BigDecimal
  underlyingTokens: [ERC20Token!]
}

type LendingToken @entity {
  id: ID!
  name: String!
  symbol: String!
  address: Bytes!
  updatedAt: BigInt!
  isPaused: Boolean
  borrowingLevelAmount: BigDecimal
  underlyingTokens: [ERC20Token!]
}

type BorrowLog @entity(immutable: true) {
  id: ID!
  amount: BigDecimal!
  asset: String!
  type: String!
  date: BigInt!
  userAddress: Bytes!
}

type LeveragedBorrowLog @entity(immutable: true) {
  id: ID!
  prjTokenPrice: BigDecimal!
  lendingTokenPrice: BigDecimal!
  marginAmount: BigDecimal!
  marginCount: BigDecimal!
  exposureAmount: BigDecimal!
  exposureLendingCount: BigDecimal!
  prjToken: String!
  lendingToken: String!
  type: String!
  date: BigInt!
  userAddress: Bytes!
  prjTokenAddress: Bytes!
  lendingTokenAddress: Bytes!
}

type Borrower @entity {
  id: ID!
  address: Bytes!
  lendingTokenAddress: Bytes!
  updatedAt: BigInt!
  borrowedAmount: BigDecimal
  outstandingAmount: BigDecimal
  depositedAmount: BigDecimal
}

type BorrowedState @entity {
  id: ID!
  lendingTokenAddress: Bytes
  updatedAt: BigInt!
  borrowerAddresses: [Borrower!]
}

type TotalState @entity {
  id: ID!
  type: String!
  amount: BigDecimal!
  lendingTokenAddress: Bytes
  updatedAt: BigInt!
}

# Update for leverage borrow position logic 
type LeveragePositionData @entity {
  # transactionHash - logIndex
  id: ID!
  borrowerAddress: PositionByUser! 
  longAsset: Bytes!
  shortAsset: Bytes!
  longCount: BigDecimal!
  shortCount: BigDecimal!
  leverageType: Int!
  projectTokenRefId: PositionByProjectToken!
  lendingTokenRefId: PositionByLendingToken!
}

type LongAssetCountState @entity {
  # user - projectToken
  id: ID!
  currentTotalLongAssetCount: BigDecimal!
  maxTotalLongAssetCount: BigDecimal!
}

type ShortAssetCountState @entity {
  # user - lendingToken
  id: ID!
  closeShortAmount: BigDecimal!
  currentShortAssetCount: BigDecimal!
  maxTotalShortAssetCount: BigDecimal!
}

type PositionByProjectToken @entity(immutable: true) {
  # user - projectToken
  id: ID!
  positions: [LeveragePositionData!]! @derivedFrom(field: "projectTokenRefId")
} 

type PositionByLendingToken @entity(immutable: true) {
  # user - lendingToken
  id: ID!
  positions: [LeveragePositionData!]! @derivedFrom(field: "lendingTokenRefId")
} 

type PositionByUser @entity(immutable: true) { 
  # user
  id: ID!
  positions: [LeveragePositionData!]! @derivedFrom(field: "borrowerAddress")
}

# End of update

type CollateralDepositedHistory @entity(immutable: true) {
  id: ID!
  amount: BigDecimal!
  lendingTokenAddress: Bytes
  date: BigInt!
}

type PITTokenHistory @entity(immutable: true) {
  id: ID!
  amount: BigDecimal!
  lendingTokenAddress: Bytes
  date: BigInt!
}

type OutstandingHistory @entity(immutable: true) {
  id: ID!
  amount: BigDecimal!
  lendingTokenAddress: Bytes
  date: BigInt!
}

# type CollateralVSLoanRatioHistory @entity(immutable: true) {
#   id: ID!
#   amount: BigDecimal!
#   lendingTokenAddress: Bytes
#   date: BigInt!
# }

type LenderAPYHistory @entity(immutable: true) {
  id: ID!
  amount: BigDecimal!
  lendingTokenAddress: Bytes
  date: BigInt!
}

type BorrowingAPYHistory @entity(immutable: true) {
  id: ID!
  amount: BigDecimal!
  lendingTokenAddress: Bytes
  date: BigInt!
}

type LenderAggregateCapitalDepositedHistory @entity(immutable: true) {
  id: ID!
  amount: BigDecimal!
  lendingTokenAddress: Bytes
  date: BigInt!
}